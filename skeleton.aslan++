specification @filename
channel_model CCM

entity Environment {
 

	types
		cookie < text;
		param < text;
		fnode < param;
		page < fnode;
		sess < text;
		nonce < text;

	symbols
		sqli_bypass, sqli, sqli_write, sqli_read: text; 			%sql injection payload
		path_injection: text; 		%valid file
		xss: text; 		% XSS payload
		xss_hijack: text;
		evil_file: text; 		%valid file
		honest, webapplication, database,filesystem: agent;
		nonpublic secureFile: text;

		% Honest entity
		nonpublic hknows : message set;


		eq, emp : text;	% used as separator
		nonpublic sanitized(message) : message;


		%DBMS
		nonpublic db: message set;
		nonpublic query(message set,message): message;
		nonpublic query_read(message) : message;
		nonpublic query_write(message,message) : message;
		nonpublic insert(message set,message): message;
		nonpublic update(message set, message, message) : message;
		nonpublic inDB(message): fact;
		nonpublic inDB_write(message): fact;
		nonpublic inDB_read(message): fact;
		nonpublic inDB_bypass(message): fact;

	
		% database structure
		@databasestructure

		%Filesystem
		nonpublic fs: message set;
		nonpublic file(message) : message;
		nonpublic writeFile(message): message;
		nonpublic readFile(message): message;
		nonpublic inFS(message): fact;

		% request 
		% page, parameters, cookie
		http_request(message, message, message): message;	

		% response
		% page, result
		http_response(message, message, message): message;	

		% none parameter
		none : text;

		@pages
		@params
		
		% messages tagss
		@tags

	clauses
		%DBMS (behavior)

		%evil behavior
		db_hc_ev(M)  : inDB((sqli.?).M);
		db_hc_ev_2(M): inDB(sqli.?);
		db_hc_ev_3(M): inDB(sqli);

		db_hc_ev_write(M)  : inDB_write((sqli_write.?).M);
		db_hc_ev_write2(M): inDB_write(sqli_write.?);
		db_hc_ev_write3(M): inDB_write(sqli_write);

		db_hc_ev_read(M)  : inDB_read((sqli_read.?).M);
		db_hc_ev_read2(M): inDB_read(sqli_read.?);
		db_hc_ev_read3(M): inDB_read(sqli_read);

		db_hc_ev_bypass(M)  : inDB_bypass((sqli_bypass.?).M);
		db_hc_ev_bypass2(M): inDB_bypass(sqli_bypass.?);
		db_hc_ev_bypass3(M): inDB_bypass(sqli_bypass);

		%FILESYSTEM (behavior)
		fs_hc_ev(M)  : inFS(path_injection.M);

entity Session(Honest, Webapplication, Database, Filesystem: agent) {

	entity Webapplication(Honest, Actor, Database, Filesystem: agent) {
		symbols
		WebNonce : nonce;
		Entity : agent;
		@webappsymbols
		body{
			while(true){
				select{
					@webappbody
				}
			}%end while
		}%end body
	}


	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% HONEST ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  entity Honest(Actor, Webapplication : agent){
	
		symbols
		  Response, RResponse, Something : message;
			Page, Params, Cookie, Tag : message;
			Redirect, Hijack, Body : message;
			WebNonce : text;
			nonpublic requestSent(message, message): fact;
			@webappsymbols
		
		body{
				while(true){
						select{
							@honestbody

								% This represent the intruder that sent a link to
								% the honest agent used for Reflected XSS but also for CSRF
								on( i *->* Actor : ?Page.?Params.?Tag ):{
									%assert o: Page !=  index | Params != u.s.xss.?.s.p.s.none | !hknows->contains(?) | Tag != tag1;
									%assert o: Page !=  insertPage | Params != comment.s.xss.insertPage | Tag != tag1;
									%assert h: exists M. hknows->contains(M) & cookieUsed(M);
									Cookie := ?;
									WebNonce := fresh();
									Actor *->* Webapplication : http_request(Page,Params,Cookie).Tag.WebNonce;
									requestSent(Tag, WebNonce);
								}

								% general rule for the honest user when he receive something
								% from the web application after sending a request
								on(Webapplication *->* Actor : http_response(?Page, ?Body, ?Cookie).WebNonce):{
									select{ on(requestSent(Tag, WebNonce)):{
								select{ on(Body = xss.?Redirect):{
												Params := ?;
												Cookie := ?;
												Tag := ?;
												WebNonce := fresh();
												% redirecting the user aka CSRF
												Actor *->* Webapplication : http_request(Redirect,Params,Cookie).Tag.WebNonce;
												redirect(Redirect);
												Webapplication *->* Actor : http_response(?Page,?Body, ?Cookie).Tag.WebNonce;
												hknows->add(Page);
												hknows->add(Body);
												hknows->add(Cookie);
											}
											% XSS for stealing the user's knowledge
											on (RResponse = xss_hijack.?Hijack):{
												Actor *->* i : hknows;
											}
										}
									}}
								}
								
						} %end select
				} %end while
		} % end body
 } % end entity
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% END HONEST ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% DATABASE ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%TODO: fix SQLquery is just one message
	
	entity Database(Webapplication, Actor, Filesystem: agent){
		symbols
			NonceWA,NonceDB,NonceFS: text;
			SQLquery, Key: message;
			File, Content: text;
			Sql, Val : message;
			Table,Tbl : message set;
			Filetmp : message set;
			Action : nat;
			
	
		body{
				while(true){
						select{ 
							% all the dishonest behavior in one place
							on(Webapplication *->* Actor : query(?Table, ?SQLquery).?NonceWA |
								 Webapplication *->* Actor : query_read(?SQLquery).?NonceWA |
								 Webapplication *->* Actor : query_write(?File,?SQLquery) |
								 Webapplication *->* Actor : insert(?Table,?SQLquery).?NonceWA):{

							
								 select{
								 		on(inDB(SQLquery)):{
								 			% the intruder gets the entire database
								 			 Actor *->* Webapplication : db.NonceWA;
								 			}

								 		 on(inDB_read(SQLquery)):{
								 		 % the intruder can to read a file from the file-system
								 		 	NonceDB := fresh();
								 		 	select{on( SQLquery = ?Sql.?File.? ):{
								 		 		Actor *->* Filesystem: readFile(File).NonceDB;
								 		 		select{on(Filesystem *->* Actor : ?Filetmp.NonceDB):{
								 		 				Actor *->* Webapplication : Filetmp.NonceWA;
								 		 		}}
								 		 	}}
								 		 }

								 		 on(inDB_write(SQLquery)):{
								 		 % the intruder can write to the file-system
								 		 	NonceDB := fresh();
								 		 	select{on( SQLquery = ?Sql.?File.?):{
								 		 		Actor *->* Filesystem: writeFile(File).NonceDB;
								 		 		Actor *->* Webapplication : file(File).NonceWA;
								 		 	}}
								 		 }
								 		 
								 		 
								 		 on(inDB(SQLquery)):{
								 		 		Table->add(SQLquery);
								 		 }

										 on(inDB_bypass(SQLquery)):{
										 select{ on(Table->contains(?Sql)):{
											Actor*->*Webapplication : Sql.NonceWA;
										 		}
										 }
										 }
								 		
								 		}
									}
								
									on(Webapplication *->* Actor : query(?Table, ?SQLquery).?NonceWA):{
										select{
											on(Table->contains(SQLquery)):{
												Actor *->* Webapplication : SQLquery.NonceWA;
											}
											on(SQLquery = sanitized(?Sql)):{
												select{ on(Table->contains(Sql)):{
													Actor *->* Webapplication : Sql.NonceWA;
												}}
											}
										}
									}

									on(Webapplication *->* Actor : query_read(?SQLquery).?NonceWA):{
										% the intruder can read from the filesystem
										NonceDB := fresh();
										select{on( SQLquery = ?Sql.?File.?):{
												Actor *->* Filesystem: readFile(File).NonceDB;
												Filesystem *->* Actor : ?Filetmp.NonceDB;
												Actor *->* Webapplication : Filetmp.NonceWA;
										}}
									}
									
									on(Webapplication *->* Actor : query_write(?File, ?SQLquery).?NonceWA):{
											% the intruder can write to the filesystem
											NonceDB := fresh();
											select{on( SQLquery = ?Sql.?File.? ):{
												Actor *->* Filesystem: writeFile(File).NonceDB;
												Actor *->* Webapplication : file(File).NonceWA;
												}}
									}

									on(Webapplication *->* Actor : insert(?Table, ?SQLquery).?NonceWA):{
											Table->add(SQLquery);
									}

									on(Webapplication *->* Actor : update(?Table, ?Key, ?SQLquery).?NonceWA):{
										Table->remove(Key);
										Table->add(SQLquery);
										Actor *->* Webapplication : SQLquery.NonceWA;
									}
						} %behavior select
		} %while 
	} %body
  }%dbEntity
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% FILESYSTEM ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	entity Filesystem(Webapplication, Actor: agent){

			symbols
				Nonce1, Nonce2: text;
				Path : text;
				Entity : agent;
				Content : message;
				Val : text;

			body{
				while(true){
					select{
						% begin honest behavior
						on(?Entity *->* Actor : readFile(?Path).?Nonce1):{
							select{
								on(fs->contains(file(Path))):{
									Actor *->* Entity : file(Path);
								}
							}
						}
						on(?Entity *->* Actor : writeFile(?Path).?Nonce1):{
							fs->add(file(Path));
						}
						% end honest behavior

						% begin dishonest behavior
						on(?Entity *->* Actor : readFile(?Path).?Nonce1):{
							select{
								on(inFS(Path)):{
									select{on(fs->contains(file(?Val))):{
										Actor *->* Entity : Val;
									}}
								}
							}
						}
						% end dishonest behavior
					} % select
				}%while
			}%body
	}%fs_entity
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	body{ %of session

		@databaseinit
		new Webapplication(honest, webapplication, database, filesystem);  
		new Database(webapplication, database, filesystem);
		new Filesystem(webapplication,filesystem);
		new Honest(honest,webapplication);
	}

	goals %of session 
		security_goal:
			[](!iknows(db));
}

body{ %of Environment
	new Session(honest,webapplication, database, filesystem);
}

}
